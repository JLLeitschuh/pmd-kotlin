options {
}

PARSER_BEGIN(KotlinParser)
public class KotlinParser {

public static void main(String[] args) {
        try {
            new KotlinParser(new java.io.StringReader(args[0])).S();
            System.out.println("Syntax is okay");
        } catch (Throwable e) {
            // Catching Throwable is ugly but JavaCC throws Error objects!
            System.out.println("Syntax check failed: " + e.getMessage());
        }
    }
}
PARSER_END(KotlinParser)

/* WHITESPACE */
SPECIAL_TOKEN :
{
  " " | "\t" | "\n" | "\r" | "\f"
}

/* COMMENTS */
SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "//"(~["\n","\r"])* ("\n"|"\r"|"\r\n")? >
}

MORE :
{
  "/*" : IN_MULTI_LINE_COMMENT
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}

/* NUMBER LITERALS */
TOKEN :
{
  < #DIGIT: ["0"-"9"]>
| < #BINARY_DIGIT: ["0"-"1"]>
| < #HEXADECIMAL_DIGIT: <DIGIT> | ["a"-"f", "A"-"F"]>

| < INTEGER_LITERAL: (<DIGIT>)+>
| < BINARY_LITERAL: "0"["b", "B"](<BINARY_DIGIT>)+>
| < HEXADECIMAL_LITERAL: "0"["x", "X"](<HEXADECIMAL_DIGIT>)+>

| < #SIGN: ["-", "+"]>
| < #SIGNED_INTEGER: (<SIGN>)?<INTEGER_LITERAL>>

| < FLOAT_LITERAL: <INTEGER_LITERAL>("."<INTEGER_LITERAL>)?(["e", "E"]<SIGNED_INTEGER>)?(["f", "F"])?>
}

/* CHARACTER AND STRING LITERALS */
TOKEN :
{
  < #SINGLE_CHARACTER: ~["'","\\","\n","\r"]>
| < #UNICODE_ESCAPE: "\\u" <HEXADECIMAL_DIGIT><HEXADECIMAL_DIGIT><HEXADECIMAL_DIGIT><HEXADECIMAL_DIGIT>>
| < #ESCAPE_SEQUENCE: ("\\"["b", "t", "n", "f", "r", "\"", "'", "\\"]) | <UNICODE_ESCAPE>>
| < CHARACTER_LITERAL: "'"(<SINGLE_CHARACTER>|<ESCAPE_SEQUENCE>)"'">

| < #STRING_CHARACTER: (~["\"","\\","\n","\r"]) | <ESCAPE_SEQUENCE>>
| < #STRING_CHARACTERS: (<STRING_CHARACTER>)+>
| < STRING_LITERAL: "\""(<STRING_CHARACTERS>)?"\"">
}

void S(): {} { E() <EOF>}
void E(): {} {<INTEGER_LITERAL> | <HEXADECIMAL_LITERAL> | <FLOAT_LITERAL>}